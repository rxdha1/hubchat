"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ufo";
exports.ids = ["vendor-chunks/ufo"];
exports.modules = {

/***/ "(ssr)/./node_modules/ufo/dist/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/ufo/dist/index.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $URL: () => (/* binding */ $URL),\n/* harmony export */   cleanDoubleSlashes: () => (/* binding */ cleanDoubleSlashes),\n/* harmony export */   createURL: () => (/* binding */ createURL),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   decodePath: () => (/* binding */ decodePath),\n/* harmony export */   decodeQueryKey: () => (/* binding */ decodeQueryKey),\n/* harmony export */   decodeQueryValue: () => (/* binding */ decodeQueryValue),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeHash: () => (/* binding */ encodeHash),\n/* harmony export */   encodeHost: () => (/* binding */ encodeHost),\n/* harmony export */   encodeParam: () => (/* binding */ encodeParam),\n/* harmony export */   encodePath: () => (/* binding */ encodePath),\n/* harmony export */   encodeQueryItem: () => (/* binding */ encodeQueryItem),\n/* harmony export */   encodeQueryKey: () => (/* binding */ encodeQueryKey),\n/* harmony export */   encodeQueryValue: () => (/* binding */ encodeQueryValue),\n/* harmony export */   getQuery: () => (/* binding */ getQuery),\n/* harmony export */   hasLeadingSlash: () => (/* binding */ hasLeadingSlash),\n/* harmony export */   hasProtocol: () => (/* binding */ hasProtocol),\n/* harmony export */   hasTrailingSlash: () => (/* binding */ hasTrailingSlash),\n/* harmony export */   isEmptyURL: () => (/* binding */ isEmptyURL),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   isNonEmptyURL: () => (/* binding */ isNonEmptyURL),\n/* harmony export */   isRelative: () => (/* binding */ isRelative),\n/* harmony export */   isSamePath: () => (/* binding */ isSamePath),\n/* harmony export */   isScriptProtocol: () => (/* binding */ isScriptProtocol),\n/* harmony export */   joinRelativeURL: () => (/* binding */ joinRelativeURL),\n/* harmony export */   joinURL: () => (/* binding */ joinURL),\n/* harmony export */   normalizeURL: () => (/* binding */ normalizeURL),\n/* harmony export */   parseAuth: () => (/* binding */ parseAuth),\n/* harmony export */   parseFilename: () => (/* binding */ parseFilename),\n/* harmony export */   parseHost: () => (/* binding */ parseHost),\n/* harmony export */   parsePath: () => (/* binding */ parsePath),\n/* harmony export */   parseQuery: () => (/* binding */ parseQuery),\n/* harmony export */   parseURL: () => (/* binding */ parseURL),\n/* harmony export */   resolveURL: () => (/* binding */ resolveURL),\n/* harmony export */   stringifyParsedURL: () => (/* binding */ stringifyParsedURL),\n/* harmony export */   stringifyQuery: () => (/* binding */ stringifyQuery),\n/* harmony export */   withBase: () => (/* binding */ withBase),\n/* harmony export */   withFragment: () => (/* binding */ withFragment),\n/* harmony export */   withHttp: () => (/* binding */ withHttp),\n/* harmony export */   withHttps: () => (/* binding */ withHttps),\n/* harmony export */   withLeadingSlash: () => (/* binding */ withLeadingSlash),\n/* harmony export */   withProtocol: () => (/* binding */ withProtocol),\n/* harmony export */   withQuery: () => (/* binding */ withQuery),\n/* harmony export */   withTrailingSlash: () => (/* binding */ withTrailingSlash),\n/* harmony export */   withoutBase: () => (/* binding */ withoutBase),\n/* harmony export */   withoutFragment: () => (/* binding */ withoutFragment),\n/* harmony export */   withoutHost: () => (/* binding */ withoutHost),\n/* harmony export */   withoutLeadingSlash: () => (/* binding */ withoutLeadingSlash),\n/* harmony export */   withoutProtocol: () => (/* binding */ withoutProtocol),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash)\n/* harmony export */ });\nconst n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = {\n  overflow: \"Overflow Error\",\n  \"not-basic\": \"Illegal Input\",\n  \"invalid-input\": \"Invalid Input\"\n};\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_CARET_RE = /%5e/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7b/gi;\nconst ENC_PIPE_RE = /%7c/gi;\nconst ENC_CURLY_CLOSE_RE = /%7d/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2f/gi;\nconst ENC_ENC_SLASH_RE = /%252f/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(input) {\n  return encode(typeof input === \"string\" ? input : JSON.stringify(input)).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CARET_RE, \"^\").replace(SLASH_RE, \"%2F\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryKey(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(parametersString = \"\") {\n  const object = {};\n  if (parametersString[0] === \"?\") {\n    parametersString = parametersString.slice(1);\n  }\n  for (const parameter of parametersString.split(\"&\")) {\n    const s = parameter.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decodeQueryKey(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (object[key] === void 0) {\n      object[key] = value;\n    } else if (Array.isArray(object[key])) {\n      object[key].push(value);\n    } else {\n      object[key] = [object[key], value];\n    }\n  }\n  return object;\n}\nfunction encodeQueryItem(key, value) {\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    value = String(value);\n  }\n  if (!value) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(value)) {\n    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join(\"&\");\n}\n\nconst PROTOCOL_STRICT_REGEX = /^[\\s\\w\\0+.-]{2,}:([/\\\\]{1,2})/;\nconst PROTOCOL_REGEX = /^[\\s\\w\\0+.-]{2,}:([/\\\\]{2})?/;\nconst PROTOCOL_RELATIVE_REGEX = /^([/\\\\]\\s*){2,}[^/\\\\]/;\nconst PROTOCOL_SCRIPT_RE = /^[\\s\\0]*(blob|data|javascript|vbscript):$/i;\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?|\\/#/;\nconst JOIN_LEADING_SLASH_RE = /^\\.?\\//;\nfunction isRelative(inputString) {\n  return [\"./\", \"../\"].some((string_) => inputString.startsWith(string_));\n}\nfunction hasProtocol(inputString, opts = {}) {\n  if (typeof opts === \"boolean\") {\n    opts = { acceptRelative: opts };\n  }\n  if (opts.strict) {\n    return PROTOCOL_STRICT_REGEX.test(inputString);\n  }\n  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);\n}\nfunction isScriptProtocol(protocol) {\n  return !!protocol && PROTOCOL_SCRIPT_RE.test(protocol);\n}\nfunction hasTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n  }\n  const [s0, ...s] = path.split(\"?\");\n  const cleanPath = s0.endsWith(\"/\") ? s0.slice(0, -1) : s0;\n  return (cleanPath || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction withTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n    if (!path) {\n      return fragment;\n    }\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((string_) => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.slice(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {\n    if (url) {\n      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, \"\");\n      url = withTrailingSlash(url) + _segment;\n    } else {\n      url = segment;\n    }\n  }\n  return url;\n}\nfunction joinRelativeURL(..._input) {\n  const JOIN_SEGMENT_SPLIT_RE = /\\/(?!\\/)/;\n  const input = _input.filter(Boolean);\n  const segments = [];\n  let segmentsDepth = 0;\n  for (const i of input) {\n    if (!i || i === \"/\") {\n      continue;\n    }\n    for (const [sindex, s] of i.split(JOIN_SEGMENT_SPLIT_RE).entries()) {\n      if (!s || s === \".\") {\n        continue;\n      }\n      if (s === \"..\") {\n        if (segments.length === 1 && hasProtocol(segments[0])) {\n          continue;\n        }\n        segments.pop();\n        segmentsDepth--;\n        continue;\n      }\n      if (sindex === 1 && segments[segments.length - 1]?.endsWith(\":/\")) {\n        segments[segments.length - 1] += \"/\" + s;\n        continue;\n      }\n      segments.push(s);\n      segmentsDepth++;\n    }\n  }\n  let url = segments.join(\"/\");\n  if (segmentsDepth >= 0) {\n    if (input[0]?.startsWith(\"/\") && !url.startsWith(\"/\")) {\n      url = \"/\" + url;\n    } else if (input[0]?.startsWith(\"./\") && !url.startsWith(\"./\")) {\n      url = \"./\" + url;\n    }\n  } else {\n    url = \"../\".repeat(-1 * segmentsDepth) + url;\n  }\n  if (input[input.length - 1]?.endsWith(\"/\") && !url.endsWith(\"/\")) {\n    url += \"/\";\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  let match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    match = input.match(/^\\/{2,}/);\n  }\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.slice(match[0].length);\n}\nfunction normalizeURL(input) {\n  const parsed = parseURL(input);\n  parsed.pathname = encodePath(decodePath(parsed.pathname));\n  parsed.hash = encodeHash(decode(parsed.hash));\n  parsed.host = encodeHost(decode(parsed.host));\n  parsed.search = stringifyQuery(parseQuery(parsed.search));\n  return stringifyParsedURL(parsed);\n}\nfunction resolveURL(base = \"\", ...inputs) {\n  if (typeof base !== \"string\") {\n    throw new TypeError(\n      `URL input should be string received ${typeof base} (${base})`\n    );\n  }\n  const filteredInputs = inputs.filter((input) => isNonEmptyURL(input));\n  if (filteredInputs.length === 0) {\n    return base;\n  }\n  const url = parseURL(base);\n  for (const inputSegment of filteredInputs) {\n    const urlSegment = parseURL(inputSegment);\n    if (urlSegment.pathname) {\n      url.pathname = withTrailingSlash(url.pathname) + withoutLeadingSlash(urlSegment.pathname);\n    }\n    if (urlSegment.hash && urlSegment.hash !== \"#\") {\n      url.hash = urlSegment.hash;\n    }\n    if (urlSegment.search && urlSegment.search !== \"?\") {\n      if (url.search && url.search !== \"?\") {\n        const queryString = stringifyQuery({\n          ...parseQuery(url.search),\n          ...parseQuery(urlSegment.search)\n        });\n        url.search = queryString.length > 0 ? \"?\" + queryString : \"\";\n      } else {\n        url.search = urlSegment.search;\n      }\n    }\n  }\n  return stringifyParsedURL(url);\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, options = {}) {\n  if (!options.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!options.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!options.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\nfunction withFragment(input, hash) {\n  if (!hash || hash === \"#\") {\n    return input;\n  }\n  const parsed = parseURL(input);\n  parsed.hash = hash === \"\" ? \"\" : \"#\" + encodeHash(hash);\n  return stringifyParsedURL(parsed);\n}\nfunction withoutFragment(input) {\n  return stringifyParsedURL({ ...parseURL(input), hash: \"\" });\n}\nfunction withoutHost(input) {\n  const parsed = parseURL(input);\n  return (parsed.pathname || \"/\") + parsed.search + parsed.hash;\n}\n\nconst protocolRelative = Symbol.for(\"ufo:protocolRelative\");\nfunction parseURL(input = \"\", defaultProto) {\n  const _specialProtoMatch = input.match(\n    /^[\\s\\0]*(blob:|data:|javascript:|vbscript:)(.*)/i\n  );\n  if (_specialProtoMatch) {\n    const [, _proto, _pathname = \"\"] = _specialProtoMatch;\n    return {\n      protocol: _proto.toLowerCase(),\n      pathname: _pathname,\n      href: _proto + _pathname,\n      auth: \"\",\n      host: \"\",\n      search: \"\",\n      hash: \"\"\n    };\n  }\n  if (!hasProtocol(input, { acceptRelative: true })) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [, protocol = \"\", auth, hostAndPath = \"\"] = input.replace(/\\\\/g, \"/\").match(/^[\\s\\0]*([\\w+.-]{2,}:)?\\/\\/([^/@]+@)?(.*)/) || [];\n  let [, host = \"\", path = \"\"] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];\n  if (protocol === \"file:\") {\n    path = path.replace(/\\/(?=[A-Za-z]:)/, \"\");\n  }\n  const { pathname, search, hash } = parsePath(path);\n  return {\n    protocol: protocol.toLowerCase(),\n    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : \"\",\n    host,\n    pathname,\n    search,\n    hash,\n    [protocolRelative]: !protocol\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/:]*):?(\\d+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const pathname = parsed.pathname || \"\";\n  const search = parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\";\n  const hash = parsed.hash || \"\";\n  const auth = parsed.auth ? parsed.auth + \"@\" : \"\";\n  const host = parsed.host || \"\";\n  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || \"\") + \"//\" : \"\";\n  return proto + auth + host + pathname + search + hash;\n}\nconst FILENAME_STRICT_REGEX = /\\/([^/]+\\.[^/]+)$/;\nconst FILENAME_REGEX = /\\/([^/]+)$/;\nfunction parseFilename(input = \"\", { strict }) {\n  const { pathname } = parseURL(input);\n  const matches = strict ? pathname.match(FILENAME_STRICT_REGEX) : pathname.match(FILENAME_REGEX);\n  return matches ? matches[1] : void 0;\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass $URL {\n  constructor(input = \"\") {\n    __publicField(this, \"protocol\");\n    __publicField(this, \"host\");\n    __publicField(this, \"auth\");\n    __publicField(this, \"pathname\");\n    __publicField(this, \"query\", {});\n    __publicField(this, \"hash\");\n    if (typeof input !== \"string\") {\n      throw new TypeError(\n        `URL input should be string received ${typeof input} (${input})`\n      );\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length > 0 ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        for (const v of value) {\n          p.append(name, v);\n        }\n      } else {\n        p.append(\n          name,\n          typeof value === \"string\" ? value : JSON.stringify(value)\n        );\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdWZvL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQ0FBaUM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CLEdBQUcseUJBQXlCO0FBQ3BGO0FBQ0EsWUFBWSxvQkFBb0IsR0FBRyx3QkFBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEdBQUcsUUFBUSxJQUFJO0FBQzNELHFDQUFxQyxHQUFHLFFBQVEsRUFBRTtBQUNsRCw2Q0FBNkMsR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsR0FBRztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixHQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYSxHQUFHLEtBQUs7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0Esc0dBQXNHLEdBQUc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjLEdBQUcsTUFBTTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5c0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL3Vmby9kaXN0L2luZGV4Lm1qcz84ZjQ1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG4gPSAvW15cXDAtXFx4N0VdLztcbmNvbnN0IHQgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nO1xuY29uc3QgbyA9IHtcbiAgb3ZlcmZsb3c6IFwiT3ZlcmZsb3cgRXJyb3JcIixcbiAgXCJub3QtYmFzaWNcIjogXCJJbGxlZ2FsIElucHV0XCIsXG4gIFwiaW52YWxpZC1pbnB1dFwiOiBcIkludmFsaWQgSW5wdXRcIlxufTtcbmNvbnN0IGUgPSBNYXRoLmZsb29yO1xuY29uc3QgciA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5mdW5jdGlvbiBzKG4yKSB7XG4gIHRocm93IG5ldyBSYW5nZUVycm9yKG9bbjJdKTtcbn1cbmNvbnN0IGMgPSBmdW5jdGlvbihuMiwgdDIpIHtcbiAgcmV0dXJuIG4yICsgMjIgKyA3NSAqIChuMiA8IDI2KSAtICgodDIgIT0gMCkgPDwgNSk7XG59O1xuY29uc3QgdSA9IGZ1bmN0aW9uKG4yLCB0MiwgbzIpIHtcbiAgbGV0IHIyID0gMDtcbiAgZm9yIChuMiA9IG8yID8gZShuMiAvIDcwMCkgOiBuMiA+PiAxLCBuMiArPSBlKG4yIC8gdDIpOyBuMiA+IDQ1NTsgcjIgKz0gMzYpIHtcbiAgICBuMiA9IGUobjIgLyAzNSk7XG4gIH1cbiAgcmV0dXJuIGUocjIgKyAzNiAqIG4yIC8gKG4yICsgMzgpKTtcbn07XG5mdW5jdGlvbiB0b0FTQ0lJKG8yKSB7XG4gIHJldHVybiBmdW5jdGlvbihuMiwgbzMpIHtcbiAgICBjb25zdCBlMiA9IG4yLnNwbGl0KFwiQFwiKTtcbiAgICBsZXQgcjIgPSBcIlwiO1xuICAgIGUyLmxlbmd0aCA+IDEgJiYgKHIyID0gZTJbMF0gKyBcIkBcIiwgbjIgPSBlMlsxXSk7XG4gICAgY29uc3QgczIgPSBmdW5jdGlvbihuMywgdDIpIHtcbiAgICAgIGNvbnN0IG80ID0gW107XG4gICAgICBsZXQgZTMgPSBuMy5sZW5ndGg7XG4gICAgICBmb3IgKDsgZTMtLTsgKSB7XG4gICAgICAgIG80W2UzXSA9IHQyKG4zW2UzXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbzQ7XG4gICAgfSgobjIgPSBuMi5yZXBsYWNlKHQsIFwiLlwiKSkuc3BsaXQoXCIuXCIpLCBvMykuam9pbihcIi5cIik7XG4gICAgcmV0dXJuIHIyICsgczI7XG4gIH0obzIsIGZ1bmN0aW9uKHQyKSB7XG4gICAgcmV0dXJuIG4udGVzdCh0MikgPyBcInhuLS1cIiArIGZ1bmN0aW9uKG4yKSB7XG4gICAgICBjb25zdCB0MyA9IFtdO1xuICAgICAgY29uc3QgbzMgPSAobjIgPSBmdW5jdGlvbihuMykge1xuICAgICAgICBjb25zdCB0NCA9IFtdO1xuICAgICAgICBsZXQgbzQgPSAwO1xuICAgICAgICBjb25zdCBlMiA9IG4zLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IG80IDwgZTI7ICkge1xuICAgICAgICAgIGNvbnN0IHIyID0gbjMuY2hhckNvZGVBdChvNCsrKTtcbiAgICAgICAgICBpZiAocjIgPj0gNTUyOTYgJiYgcjIgPD0gNTYzMTkgJiYgbzQgPCBlMikge1xuICAgICAgICAgICAgY29uc3QgZTMgPSBuMy5jaGFyQ29kZUF0KG80KyspO1xuICAgICAgICAgICAgKDY0NTEyICYgZTMpID09IDU2MzIwID8gdDQucHVzaCgoKDEwMjMgJiByMikgPDwgMTApICsgKDEwMjMgJiBlMykgKyA2NTUzNikgOiAodDQucHVzaChyMiksIG80LS0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0NC5wdXNoKHIyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ0O1xuICAgICAgfShuMikpLmxlbmd0aDtcbiAgICAgIGxldCBmID0gMTI4O1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgbGV0IGwgPSA3MjtcbiAgICAgIGZvciAoY29uc3QgbzQgb2YgbjIpIHtcbiAgICAgICAgbzQgPCAxMjggJiYgdDMucHVzaChyKG80KSk7XG4gICAgICB9XG4gICAgICBjb25zdCBoID0gdDMubGVuZ3RoO1xuICAgICAgbGV0IHAgPSBoO1xuICAgICAgZm9yIChoICYmIHQzLnB1c2goXCItXCIpOyBwIDwgbzM7ICkge1xuICAgICAgICBsZXQgbzQgPSAyMTQ3NDgzNjQ3O1xuICAgICAgICBmb3IgKGNvbnN0IHQ0IG9mIG4yKSB7XG4gICAgICAgICAgdDQgPj0gZiAmJiB0NCA8IG80ICYmIChvNCA9IHQ0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhID0gcCArIDE7XG4gICAgICAgIG80IC0gZiA+IGUoKDIxNDc0ODM2NDcgLSBpKSAvIGEpICYmIHMoXCJvdmVyZmxvd1wiKSwgaSArPSAobzQgLSBmKSAqIGEsIGYgPSBvNDtcbiAgICAgICAgZm9yIChjb25zdCBvNSBvZiBuMikge1xuICAgICAgICAgIGlmIChvNSA8IGYgJiYgKytpID4gMjE0NzQ4MzY0NyAmJiBzKFwib3ZlcmZsb3dcIiksIG81ID09IGYpIHtcbiAgICAgICAgICAgIGxldCBuMyA9IGk7XG4gICAgICAgICAgICBmb3IgKGxldCBvNiA9IDM2OyA7IG82ICs9IDM2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHMyID0gbzYgPD0gbCA/IDEgOiBvNiA+PSBsICsgMjYgPyAyNiA6IG82IC0gbDtcbiAgICAgICAgICAgICAgaWYgKG4zIDwgczIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCB1MiA9IG4zIC0gczI7XG4gICAgICAgICAgICAgIGNvbnN0IGYyID0gMzYgLSBzMjtcbiAgICAgICAgICAgICAgdDMucHVzaChyKGMoczIgKyB1MiAlIGYyLCAwKSkpLCBuMyA9IGUodTIgLyBmMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0My5wdXNoKHIoYyhuMywgMCkpKSwgbCA9IHUoaSwgYSwgcCA9PSBoKSwgaSA9IDAsICsrcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKytpLCArK2Y7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDMuam9pbihcIlwiKTtcbiAgICB9KHQyKSA6IHQyO1xuICB9KTtcbn1cblxuY29uc3QgSEFTSF9SRSA9IC8jL2c7XG5jb25zdCBBTVBFUlNBTkRfUkUgPSAvJi9nO1xuY29uc3QgU0xBU0hfUkUgPSAvXFwvL2c7XG5jb25zdCBFUVVBTF9SRSA9IC89L2c7XG5jb25zdCBJTV9SRSA9IC9cXD8vZztcbmNvbnN0IFBMVVNfUkUgPSAvXFwrL2c7XG5jb25zdCBFTkNfQ0FSRVRfUkUgPSAvJTVlL2dpO1xuY29uc3QgRU5DX0JBQ0tUSUNLX1JFID0gLyU2MC9naTtcbmNvbnN0IEVOQ19DVVJMWV9PUEVOX1JFID0gLyU3Yi9naTtcbmNvbnN0IEVOQ19QSVBFX1JFID0gLyU3Yy9naTtcbmNvbnN0IEVOQ19DVVJMWV9DTE9TRV9SRSA9IC8lN2QvZ2k7XG5jb25zdCBFTkNfU1BBQ0VfUkUgPSAvJTIwL2dpO1xuY29uc3QgRU5DX1NMQVNIX1JFID0gLyUyZi9naTtcbmNvbnN0IEVOQ19FTkNfU0xBU0hfUkUgPSAvJTI1MmYvZ2k7XG5mdW5jdGlvbiBlbmNvZGUodGV4dCkge1xuICByZXR1cm4gZW5jb2RlVVJJKFwiXCIgKyB0ZXh0KS5yZXBsYWNlKEVOQ19QSVBFX1JFLCBcInxcIik7XG59XG5mdW5jdGlvbiBlbmNvZGVIYXNoKHRleHQpIHtcbiAgcmV0dXJuIGVuY29kZSh0ZXh0KS5yZXBsYWNlKEVOQ19DVVJMWV9PUEVOX1JFLCBcIntcIikucmVwbGFjZShFTkNfQ1VSTFlfQ0xPU0VfUkUsIFwifVwiKS5yZXBsYWNlKEVOQ19DQVJFVF9SRSwgXCJeXCIpO1xufVxuZnVuY3Rpb24gZW5jb2RlUXVlcnlWYWx1ZShpbnB1dCkge1xuICByZXR1cm4gZW5jb2RlKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiA/IGlucHV0IDogSlNPTi5zdHJpbmdpZnkoaW5wdXQpKS5yZXBsYWNlKFBMVVNfUkUsIFwiJTJCXCIpLnJlcGxhY2UoRU5DX1NQQUNFX1JFLCBcIitcIikucmVwbGFjZShIQVNIX1JFLCBcIiUyM1wiKS5yZXBsYWNlKEFNUEVSU0FORF9SRSwgXCIlMjZcIikucmVwbGFjZShFTkNfQkFDS1RJQ0tfUkUsIFwiYFwiKS5yZXBsYWNlKEVOQ19DQVJFVF9SRSwgXCJeXCIpLnJlcGxhY2UoU0xBU0hfUkUsIFwiJTJGXCIpO1xufVxuZnVuY3Rpb24gZW5jb2RlUXVlcnlLZXkodGV4dCkge1xuICByZXR1cm4gZW5jb2RlUXVlcnlWYWx1ZSh0ZXh0KS5yZXBsYWNlKEVRVUFMX1JFLCBcIiUzRFwiKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVBhdGgodGV4dCkge1xuICByZXR1cm4gZW5jb2RlKHRleHQpLnJlcGxhY2UoSEFTSF9SRSwgXCIlMjNcIikucmVwbGFjZShJTV9SRSwgXCIlM0ZcIikucmVwbGFjZShFTkNfRU5DX1NMQVNIX1JFLCBcIiUyRlwiKS5yZXBsYWNlKEFNUEVSU0FORF9SRSwgXCIlMjZcIikucmVwbGFjZShQTFVTX1JFLCBcIiUyQlwiKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVBhcmFtKHRleHQpIHtcbiAgcmV0dXJuIGVuY29kZVBhdGgodGV4dCkucmVwbGFjZShTTEFTSF9SRSwgXCIlMkZcIik7XG59XG5mdW5jdGlvbiBkZWNvZGUodGV4dCA9IFwiXCIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KFwiXCIgKyB0ZXh0KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFwiXCIgKyB0ZXh0O1xuICB9XG59XG5mdW5jdGlvbiBkZWNvZGVQYXRoKHRleHQpIHtcbiAgcmV0dXJuIGRlY29kZSh0ZXh0LnJlcGxhY2UoRU5DX1NMQVNIX1JFLCBcIiUyNTJGXCIpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVF1ZXJ5S2V5KHRleHQpIHtcbiAgcmV0dXJuIGRlY29kZSh0ZXh0LnJlcGxhY2UoUExVU19SRSwgXCIgXCIpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVF1ZXJ5VmFsdWUodGV4dCkge1xuICByZXR1cm4gZGVjb2RlKHRleHQucmVwbGFjZShQTFVTX1JFLCBcIiBcIikpO1xufVxuZnVuY3Rpb24gZW5jb2RlSG9zdChuYW1lID0gXCJcIikge1xuICByZXR1cm4gdG9BU0NJSShuYW1lKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VRdWVyeShwYXJhbWV0ZXJzU3RyaW5nID0gXCJcIikge1xuICBjb25zdCBvYmplY3QgPSB7fTtcbiAgaWYgKHBhcmFtZXRlcnNTdHJpbmdbMF0gPT09IFwiP1wiKSB7XG4gICAgcGFyYW1ldGVyc1N0cmluZyA9IHBhcmFtZXRlcnNTdHJpbmcuc2xpY2UoMSk7XG4gIH1cbiAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2YgcGFyYW1ldGVyc1N0cmluZy5zcGxpdChcIiZcIikpIHtcbiAgICBjb25zdCBzID0gcGFyYW1ldGVyLm1hdGNoKC8oW149XSspPT8oLiopLykgfHwgW107XG4gICAgaWYgKHMubGVuZ3RoIDwgMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGRlY29kZVF1ZXJ5S2V5KHNbMV0pO1xuICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIgfHwga2V5ID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGRlY29kZVF1ZXJ5VmFsdWUoc1syXSB8fCBcIlwiKTtcbiAgICBpZiAob2JqZWN0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0W2tleV0pKSB7XG4gICAgICBvYmplY3Rba2V5XS5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0W2tleV0gPSBbb2JqZWN0W2tleV0sIHZhbHVlXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGVuY29kZVF1ZXJ5SXRlbShrZXksIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgfVxuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIGVuY29kZVF1ZXJ5S2V5KGtleSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcCgoX3ZhbHVlKSA9PiBgJHtlbmNvZGVRdWVyeUtleShrZXkpfT0ke2VuY29kZVF1ZXJ5VmFsdWUoX3ZhbHVlKX1gKS5qb2luKFwiJlwiKTtcbiAgfVxuICByZXR1cm4gYCR7ZW5jb2RlUXVlcnlLZXkoa2V5KX09JHtlbmNvZGVRdWVyeVZhbHVlKHZhbHVlKX1gO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHF1ZXJ5KS5maWx0ZXIoKGspID0+IHF1ZXJ5W2tdICE9PSB2b2lkIDApLm1hcCgoaykgPT4gZW5jb2RlUXVlcnlJdGVtKGssIHF1ZXJ5W2tdKSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCImXCIpO1xufVxuXG5jb25zdCBQUk9UT0NPTF9TVFJJQ1RfUkVHRVggPSAvXltcXHNcXHdcXDArLi1dezIsfTooWy9cXFxcXXsxLDJ9KS87XG5jb25zdCBQUk9UT0NPTF9SRUdFWCA9IC9eW1xcc1xcd1xcMCsuLV17Mix9OihbL1xcXFxdezJ9KT8vO1xuY29uc3QgUFJPVE9DT0xfUkVMQVRJVkVfUkVHRVggPSAvXihbL1xcXFxdXFxzKil7Mix9W14vXFxcXF0vO1xuY29uc3QgUFJPVE9DT0xfU0NSSVBUX1JFID0gL15bXFxzXFwwXSooYmxvYnxkYXRhfGphdmFzY3JpcHR8dmJzY3JpcHQpOiQvaTtcbmNvbnN0IFRSQUlMSU5HX1NMQVNIX1JFID0gL1xcLyR8XFwvXFw/fFxcLyMvO1xuY29uc3QgSk9JTl9MRUFESU5HX1NMQVNIX1JFID0gL15cXC4/XFwvLztcbmZ1bmN0aW9uIGlzUmVsYXRpdmUoaW5wdXRTdHJpbmcpIHtcbiAgcmV0dXJuIFtcIi4vXCIsIFwiLi4vXCJdLnNvbWUoKHN0cmluZ18pID0+IGlucHV0U3RyaW5nLnN0YXJ0c1dpdGgoc3RyaW5nXykpO1xufVxuZnVuY3Rpb24gaGFzUHJvdG9jb2woaW5wdXRTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdHMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgb3B0cyA9IHsgYWNjZXB0UmVsYXRpdmU6IG9wdHMgfTtcbiAgfVxuICBpZiAob3B0cy5zdHJpY3QpIHtcbiAgICByZXR1cm4gUFJPVE9DT0xfU1RSSUNUX1JFR0VYLnRlc3QoaW5wdXRTdHJpbmcpO1xuICB9XG4gIHJldHVybiBQUk9UT0NPTF9SRUdFWC50ZXN0KGlucHV0U3RyaW5nKSB8fCAob3B0cy5hY2NlcHRSZWxhdGl2ZSA/IFBST1RPQ09MX1JFTEFUSVZFX1JFR0VYLnRlc3QoaW5wdXRTdHJpbmcpIDogZmFsc2UpO1xufVxuZnVuY3Rpb24gaXNTY3JpcHRQcm90b2NvbChwcm90b2NvbCkge1xuICByZXR1cm4gISFwcm90b2NvbCAmJiBQUk9UT0NPTF9TQ1JJUFRfUkUudGVzdChwcm90b2NvbCk7XG59XG5mdW5jdGlvbiBoYXNUcmFpbGluZ1NsYXNoKGlucHV0ID0gXCJcIiwgcmVzcGVjdFF1ZXJ5QW5kRnJhZ21lbnQpIHtcbiAgaWYgKCFyZXNwZWN0UXVlcnlBbmRGcmFnbWVudCkge1xuICAgIHJldHVybiBpbnB1dC5lbmRzV2l0aChcIi9cIik7XG4gIH1cbiAgcmV0dXJuIFRSQUlMSU5HX1NMQVNIX1JFLnRlc3QoaW5wdXQpO1xufVxuZnVuY3Rpb24gd2l0aG91dFRyYWlsaW5nU2xhc2goaW5wdXQgPSBcIlwiLCByZXNwZWN0UXVlcnlBbmRGcmFnbWVudCkge1xuICBpZiAoIXJlc3BlY3RRdWVyeUFuZEZyYWdtZW50KSB7XG4gICAgcmV0dXJuIChoYXNUcmFpbGluZ1NsYXNoKGlucHV0KSA/IGlucHV0LnNsaWNlKDAsIC0xKSA6IGlucHV0KSB8fCBcIi9cIjtcbiAgfVxuICBpZiAoIWhhc1RyYWlsaW5nU2xhc2goaW5wdXQsIHRydWUpKSB7XG4gICAgcmV0dXJuIGlucHV0IHx8IFwiL1wiO1xuICB9XG4gIGxldCBwYXRoID0gaW5wdXQ7XG4gIGxldCBmcmFnbWVudCA9IFwiXCI7XG4gIGNvbnN0IGZyYWdtZW50SW5kZXggPSBpbnB1dC5pbmRleE9mKFwiI1wiKTtcbiAgaWYgKGZyYWdtZW50SW5kZXggPj0gMCkge1xuICAgIHBhdGggPSBpbnB1dC5zbGljZSgwLCBmcmFnbWVudEluZGV4KTtcbiAgICBmcmFnbWVudCA9IGlucHV0LnNsaWNlKGZyYWdtZW50SW5kZXgpO1xuICB9XG4gIGNvbnN0IFtzMCwgLi4uc10gPSBwYXRoLnNwbGl0KFwiP1wiKTtcbiAgY29uc3QgY2xlYW5QYXRoID0gczAuZW5kc1dpdGgoXCIvXCIpID8gczAuc2xpY2UoMCwgLTEpIDogczA7XG4gIHJldHVybiAoY2xlYW5QYXRoIHx8IFwiL1wiKSArIChzLmxlbmd0aCA+IDAgPyBgPyR7cy5qb2luKFwiP1wiKX1gIDogXCJcIikgKyBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIHdpdGhUcmFpbGluZ1NsYXNoKGlucHV0ID0gXCJcIiwgcmVzcGVjdFF1ZXJ5QW5kRnJhZ21lbnQpIHtcbiAgaWYgKCFyZXNwZWN0UXVlcnlBbmRGcmFnbWVudCkge1xuICAgIHJldHVybiBpbnB1dC5lbmRzV2l0aChcIi9cIikgPyBpbnB1dCA6IGlucHV0ICsgXCIvXCI7XG4gIH1cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2goaW5wdXQsIHRydWUpKSB7XG4gICAgcmV0dXJuIGlucHV0IHx8IFwiL1wiO1xuICB9XG4gIGxldCBwYXRoID0gaW5wdXQ7XG4gIGxldCBmcmFnbWVudCA9IFwiXCI7XG4gIGNvbnN0IGZyYWdtZW50SW5kZXggPSBpbnB1dC5pbmRleE9mKFwiI1wiKTtcbiAgaWYgKGZyYWdtZW50SW5kZXggPj0gMCkge1xuICAgIHBhdGggPSBpbnB1dC5zbGljZSgwLCBmcmFnbWVudEluZGV4KTtcbiAgICBmcmFnbWVudCA9IGlucHV0LnNsaWNlKGZyYWdtZW50SW5kZXgpO1xuICAgIGlmICghcGF0aCkge1xuICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH1cbiAgfVxuICBjb25zdCBbczAsIC4uLnNdID0gcGF0aC5zcGxpdChcIj9cIik7XG4gIHJldHVybiBzMCArIFwiL1wiICsgKHMubGVuZ3RoID4gMCA/IGA/JHtzLmpvaW4oXCI/XCIpfWAgOiBcIlwiKSArIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gaGFzTGVhZGluZ1NsYXNoKGlucHV0ID0gXCJcIikge1xuICByZXR1cm4gaW5wdXQuc3RhcnRzV2l0aChcIi9cIik7XG59XG5mdW5jdGlvbiB3aXRob3V0TGVhZGluZ1NsYXNoKGlucHV0ID0gXCJcIikge1xuICByZXR1cm4gKGhhc0xlYWRpbmdTbGFzaChpbnB1dCkgPyBpbnB1dC5zbGljZSgxKSA6IGlucHV0KSB8fCBcIi9cIjtcbn1cbmZ1bmN0aW9uIHdpdGhMZWFkaW5nU2xhc2goaW5wdXQgPSBcIlwiKSB7XG4gIHJldHVybiBoYXNMZWFkaW5nU2xhc2goaW5wdXQpID8gaW5wdXQgOiBcIi9cIiArIGlucHV0O1xufVxuZnVuY3Rpb24gY2xlYW5Eb3VibGVTbGFzaGVzKGlucHV0ID0gXCJcIikge1xuICByZXR1cm4gaW5wdXQuc3BsaXQoXCI6Ly9cIikubWFwKChzdHJpbmdfKSA9PiBzdHJpbmdfLnJlcGxhY2UoL1xcL3syLH0vZywgXCIvXCIpKS5qb2luKFwiOi8vXCIpO1xufVxuZnVuY3Rpb24gd2l0aEJhc2UoaW5wdXQsIGJhc2UpIHtcbiAgaWYgKGlzRW1wdHlVUkwoYmFzZSkgfHwgaGFzUHJvdG9jb2woaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGNvbnN0IF9iYXNlID0gd2l0aG91dFRyYWlsaW5nU2xhc2goYmFzZSk7XG4gIGlmIChpbnB1dC5zdGFydHNXaXRoKF9iYXNlKSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICByZXR1cm4gam9pblVSTChfYmFzZSwgaW5wdXQpO1xufVxuZnVuY3Rpb24gd2l0aG91dEJhc2UoaW5wdXQsIGJhc2UpIHtcbiAgaWYgKGlzRW1wdHlVUkwoYmFzZSkpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgY29uc3QgX2Jhc2UgPSB3aXRob3V0VHJhaWxpbmdTbGFzaChiYXNlKTtcbiAgaWYgKCFpbnB1dC5zdGFydHNXaXRoKF9iYXNlKSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICBjb25zdCB0cmltbWVkID0gaW5wdXQuc2xpY2UoX2Jhc2UubGVuZ3RoKTtcbiAgcmV0dXJuIHRyaW1tZWRbMF0gPT09IFwiL1wiID8gdHJpbW1lZCA6IFwiL1wiICsgdHJpbW1lZDtcbn1cbmZ1bmN0aW9uIHdpdGhRdWVyeShpbnB1dCwgcXVlcnkpIHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2VVUkwoaW5wdXQpO1xuICBjb25zdCBtZXJnZWRRdWVyeSA9IHsgLi4ucGFyc2VRdWVyeShwYXJzZWQuc2VhcmNoKSwgLi4ucXVlcnkgfTtcbiAgcGFyc2VkLnNlYXJjaCA9IHN0cmluZ2lmeVF1ZXJ5KG1lcmdlZFF1ZXJ5KTtcbiAgcmV0dXJuIHN0cmluZ2lmeVBhcnNlZFVSTChwYXJzZWQpO1xufVxuZnVuY3Rpb24gZ2V0UXVlcnkoaW5wdXQpIHtcbiAgcmV0dXJuIHBhcnNlUXVlcnkocGFyc2VVUkwoaW5wdXQpLnNlYXJjaCk7XG59XG5mdW5jdGlvbiBpc0VtcHR5VVJMKHVybCkge1xuICByZXR1cm4gIXVybCB8fCB1cmwgPT09IFwiL1wiO1xufVxuZnVuY3Rpb24gaXNOb25FbXB0eVVSTCh1cmwpIHtcbiAgcmV0dXJuIHVybCAmJiB1cmwgIT09IFwiL1wiO1xufVxuZnVuY3Rpb24gam9pblVSTChiYXNlLCAuLi5pbnB1dCkge1xuICBsZXQgdXJsID0gYmFzZSB8fCBcIlwiO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgaW5wdXQuZmlsdGVyKCh1cmwyKSA9PiBpc05vbkVtcHR5VVJMKHVybDIpKSkge1xuICAgIGlmICh1cmwpIHtcbiAgICAgIGNvbnN0IF9zZWdtZW50ID0gc2VnbWVudC5yZXBsYWNlKEpPSU5fTEVBRElOR19TTEFTSF9SRSwgXCJcIik7XG4gICAgICB1cmwgPSB3aXRoVHJhaWxpbmdTbGFzaCh1cmwpICsgX3NlZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVybCA9IHNlZ21lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB1cmw7XG59XG5mdW5jdGlvbiBqb2luUmVsYXRpdmVVUkwoLi4uX2lucHV0KSB7XG4gIGNvbnN0IEpPSU5fU0VHTUVOVF9TUExJVF9SRSA9IC9cXC8oPyFcXC8pLztcbiAgY29uc3QgaW5wdXQgPSBfaW5wdXQuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICBsZXQgc2VnbWVudHNEZXB0aCA9IDA7XG4gIGZvciAoY29uc3QgaSBvZiBpbnB1dCkge1xuICAgIGlmICghaSB8fCBpID09PSBcIi9cIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW3NpbmRleCwgc10gb2YgaS5zcGxpdChKT0lOX1NFR01FTlRfU1BMSVRfUkUpLmVudHJpZXMoKSkge1xuICAgICAgaWYgKCFzIHx8IHMgPT09IFwiLlwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHMgPT09IFwiLi5cIikge1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAxICYmIGhhc1Byb3RvY29sKHNlZ21lbnRzWzBdKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICBzZWdtZW50c0RlcHRoLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNpbmRleCA9PT0gMSAmJiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXT8uZW5kc1dpdGgoXCI6L1wiKSkge1xuICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSArPSBcIi9cIiArIHM7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc2VnbWVudHMucHVzaChzKTtcbiAgICAgIHNlZ21lbnRzRGVwdGgrKztcbiAgICB9XG4gIH1cbiAgbGV0IHVybCA9IHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICBpZiAoc2VnbWVudHNEZXB0aCA+PSAwKSB7XG4gICAgaWYgKGlucHV0WzBdPy5zdGFydHNXaXRoKFwiL1wiKSAmJiAhdXJsLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICB1cmwgPSBcIi9cIiArIHVybDtcbiAgICB9IGVsc2UgaWYgKGlucHV0WzBdPy5zdGFydHNXaXRoKFwiLi9cIikgJiYgIXVybC5zdGFydHNXaXRoKFwiLi9cIikpIHtcbiAgICAgIHVybCA9IFwiLi9cIiArIHVybDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gXCIuLi9cIi5yZXBlYXQoLTEgKiBzZWdtZW50c0RlcHRoKSArIHVybDtcbiAgfVxuICBpZiAoaW5wdXRbaW5wdXQubGVuZ3RoIC0gMV0/LmVuZHNXaXRoKFwiL1wiKSAmJiAhdXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgIHVybCArPSBcIi9cIjtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gd2l0aEh0dHAoaW5wdXQpIHtcbiAgcmV0dXJuIHdpdGhQcm90b2NvbChpbnB1dCwgXCJodHRwOi8vXCIpO1xufVxuZnVuY3Rpb24gd2l0aEh0dHBzKGlucHV0KSB7XG4gIHJldHVybiB3aXRoUHJvdG9jb2woaW5wdXQsIFwiaHR0cHM6Ly9cIik7XG59XG5mdW5jdGlvbiB3aXRob3V0UHJvdG9jb2woaW5wdXQpIHtcbiAgcmV0dXJuIHdpdGhQcm90b2NvbChpbnB1dCwgXCJcIik7XG59XG5mdW5jdGlvbiB3aXRoUHJvdG9jb2woaW5wdXQsIHByb3RvY29sKSB7XG4gIGxldCBtYXRjaCA9IGlucHV0Lm1hdGNoKFBST1RPQ09MX1JFR0VYKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIG1hdGNoID0gaW5wdXQubWF0Y2goL15cXC97Mix9Lyk7XG4gIH1cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBwcm90b2NvbCArIGlucHV0O1xuICB9XG4gIHJldHVybiBwcm90b2NvbCArIGlucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVVUkwoaW5wdXQpIHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2VVUkwoaW5wdXQpO1xuICBwYXJzZWQucGF0aG5hbWUgPSBlbmNvZGVQYXRoKGRlY29kZVBhdGgocGFyc2VkLnBhdGhuYW1lKSk7XG4gIHBhcnNlZC5oYXNoID0gZW5jb2RlSGFzaChkZWNvZGUocGFyc2VkLmhhc2gpKTtcbiAgcGFyc2VkLmhvc3QgPSBlbmNvZGVIb3N0KGRlY29kZShwYXJzZWQuaG9zdCkpO1xuICBwYXJzZWQuc2VhcmNoID0gc3RyaW5naWZ5UXVlcnkocGFyc2VRdWVyeShwYXJzZWQuc2VhcmNoKSk7XG4gIHJldHVybiBzdHJpbmdpZnlQYXJzZWRVUkwocGFyc2VkKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVVUkwoYmFzZSA9IFwiXCIsIC4uLmlucHV0cykge1xuICBpZiAodHlwZW9mIGJhc2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYFVSTCBpbnB1dCBzaG91bGQgYmUgc3RyaW5nIHJlY2VpdmVkICR7dHlwZW9mIGJhc2V9ICgke2Jhc2V9KWBcbiAgICApO1xuICB9XG4gIGNvbnN0IGZpbHRlcmVkSW5wdXRzID0gaW5wdXRzLmZpbHRlcigoaW5wdXQpID0+IGlzTm9uRW1wdHlVUkwoaW5wdXQpKTtcbiAgaWYgKGZpbHRlcmVkSW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IHVybCA9IHBhcnNlVVJMKGJhc2UpO1xuICBmb3IgKGNvbnN0IGlucHV0U2VnbWVudCBvZiBmaWx0ZXJlZElucHV0cykge1xuICAgIGNvbnN0IHVybFNlZ21lbnQgPSBwYXJzZVVSTChpbnB1dFNlZ21lbnQpO1xuICAgIGlmICh1cmxTZWdtZW50LnBhdGhuYW1lKSB7XG4gICAgICB1cmwucGF0aG5hbWUgPSB3aXRoVHJhaWxpbmdTbGFzaCh1cmwucGF0aG5hbWUpICsgd2l0aG91dExlYWRpbmdTbGFzaCh1cmxTZWdtZW50LnBhdGhuYW1lKTtcbiAgICB9XG4gICAgaWYgKHVybFNlZ21lbnQuaGFzaCAmJiB1cmxTZWdtZW50Lmhhc2ggIT09IFwiI1wiKSB7XG4gICAgICB1cmwuaGFzaCA9IHVybFNlZ21lbnQuaGFzaDtcbiAgICB9XG4gICAgaWYgKHVybFNlZ21lbnQuc2VhcmNoICYmIHVybFNlZ21lbnQuc2VhcmNoICE9PSBcIj9cIikge1xuICAgICAgaWYgKHVybC5zZWFyY2ggJiYgdXJsLnNlYXJjaCAhPT0gXCI/XCIpIHtcbiAgICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSBzdHJpbmdpZnlRdWVyeSh7XG4gICAgICAgICAgLi4ucGFyc2VRdWVyeSh1cmwuc2VhcmNoKSxcbiAgICAgICAgICAuLi5wYXJzZVF1ZXJ5KHVybFNlZ21lbnQuc2VhcmNoKVxuICAgICAgICB9KTtcbiAgICAgICAgdXJsLnNlYXJjaCA9IHF1ZXJ5U3RyaW5nLmxlbmd0aCA+IDAgPyBcIj9cIiArIHF1ZXJ5U3RyaW5nIDogXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC5zZWFyY2ggPSB1cmxTZWdtZW50LnNlYXJjaDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZ2lmeVBhcnNlZFVSTCh1cmwpO1xufVxuZnVuY3Rpb24gaXNTYW1lUGF0aChwMSwgcDIpIHtcbiAgcmV0dXJuIGRlY29kZSh3aXRob3V0VHJhaWxpbmdTbGFzaChwMSkpID09PSBkZWNvZGUod2l0aG91dFRyYWlsaW5nU2xhc2gocDIpKTtcbn1cbmZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghb3B0aW9ucy50cmFpbGluZ1NsYXNoKSB7XG4gICAgYSA9IHdpdGhUcmFpbGluZ1NsYXNoKGEpO1xuICAgIGIgPSB3aXRoVHJhaWxpbmdTbGFzaChiKTtcbiAgfVxuICBpZiAoIW9wdGlvbnMubGVhZGluZ1NsYXNoKSB7XG4gICAgYSA9IHdpdGhMZWFkaW5nU2xhc2goYSk7XG4gICAgYiA9IHdpdGhMZWFkaW5nU2xhc2goYik7XG4gIH1cbiAgaWYgKCFvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgYSA9IGRlY29kZShhKTtcbiAgICBiID0gZGVjb2RlKGIpO1xuICB9XG4gIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gd2l0aEZyYWdtZW50KGlucHV0LCBoYXNoKSB7XG4gIGlmICghaGFzaCB8fCBoYXNoID09PSBcIiNcIikge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICBjb25zdCBwYXJzZWQgPSBwYXJzZVVSTChpbnB1dCk7XG4gIHBhcnNlZC5oYXNoID0gaGFzaCA9PT0gXCJcIiA/IFwiXCIgOiBcIiNcIiArIGVuY29kZUhhc2goaGFzaCk7XG4gIHJldHVybiBzdHJpbmdpZnlQYXJzZWRVUkwocGFyc2VkKTtcbn1cbmZ1bmN0aW9uIHdpdGhvdXRGcmFnbWVudChpbnB1dCkge1xuICByZXR1cm4gc3RyaW5naWZ5UGFyc2VkVVJMKHsgLi4ucGFyc2VVUkwoaW5wdXQpLCBoYXNoOiBcIlwiIH0pO1xufVxuZnVuY3Rpb24gd2l0aG91dEhvc3QoaW5wdXQpIHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2VVUkwoaW5wdXQpO1xuICByZXR1cm4gKHBhcnNlZC5wYXRobmFtZSB8fCBcIi9cIikgKyBwYXJzZWQuc2VhcmNoICsgcGFyc2VkLmhhc2g7XG59XG5cbmNvbnN0IHByb3RvY29sUmVsYXRpdmUgPSBTeW1ib2wuZm9yKFwidWZvOnByb3RvY29sUmVsYXRpdmVcIik7XG5mdW5jdGlvbiBwYXJzZVVSTChpbnB1dCA9IFwiXCIsIGRlZmF1bHRQcm90bykge1xuICBjb25zdCBfc3BlY2lhbFByb3RvTWF0Y2ggPSBpbnB1dC5tYXRjaChcbiAgICAvXltcXHNcXDBdKihibG9iOnxkYXRhOnxqYXZhc2NyaXB0Onx2YnNjcmlwdDopKC4qKS9pXG4gICk7XG4gIGlmIChfc3BlY2lhbFByb3RvTWF0Y2gpIHtcbiAgICBjb25zdCBbLCBfcHJvdG8sIF9wYXRobmFtZSA9IFwiXCJdID0gX3NwZWNpYWxQcm90b01hdGNoO1xuICAgIHJldHVybiB7XG4gICAgICBwcm90b2NvbDogX3Byb3RvLnRvTG93ZXJDYXNlKCksXG4gICAgICBwYXRobmFtZTogX3BhdGhuYW1lLFxuICAgICAgaHJlZjogX3Byb3RvICsgX3BhdGhuYW1lLFxuICAgICAgYXV0aDogXCJcIixcbiAgICAgIGhvc3Q6IFwiXCIsXG4gICAgICBzZWFyY2g6IFwiXCIsXG4gICAgICBoYXNoOiBcIlwiXG4gICAgfTtcbiAgfVxuICBpZiAoIWhhc1Byb3RvY29sKGlucHV0LCB7IGFjY2VwdFJlbGF0aXZlOiB0cnVlIH0pKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRQcm90byA/IHBhcnNlVVJMKGRlZmF1bHRQcm90byArIGlucHV0KSA6IHBhcnNlUGF0aChpbnB1dCk7XG4gIH1cbiAgY29uc3QgWywgcHJvdG9jb2wgPSBcIlwiLCBhdXRoLCBob3N0QW5kUGF0aCA9IFwiXCJdID0gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCBcIi9cIikubWF0Y2goL15bXFxzXFwwXSooW1xcdysuLV17Mix9Oik/XFwvXFwvKFteL0BdK0ApPyguKikvKSB8fCBbXTtcbiAgbGV0IFssIGhvc3QgPSBcIlwiLCBwYXRoID0gXCJcIl0gPSBob3N0QW5kUGF0aC5tYXRjaCgvKFteIy8/XSopKC4qKT8vKSB8fCBbXTtcbiAgaWYgKHByb3RvY29sID09PSBcImZpbGU6XCIpIHtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8oPz1bQS1aYS16XTopLywgXCJcIik7XG4gIH1cbiAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0gPSBwYXJzZVBhdGgocGF0aCk7XG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IHByb3RvY29sLnRvTG93ZXJDYXNlKCksXG4gICAgYXV0aDogYXV0aCA/IGF1dGguc2xpY2UoMCwgTWF0aC5tYXgoMCwgYXV0aC5sZW5ndGggLSAxKSkgOiBcIlwiLFxuICAgIGhvc3QsXG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoLFxuICAgIGhhc2gsXG4gICAgW3Byb3RvY29sUmVsYXRpdmVdOiAhcHJvdG9jb2xcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGF0aChpbnB1dCA9IFwiXCIpIHtcbiAgY29uc3QgW3BhdGhuYW1lID0gXCJcIiwgc2VhcmNoID0gXCJcIiwgaGFzaCA9IFwiXCJdID0gKGlucHV0Lm1hdGNoKC8oW14jP10qKShcXD9bXiNdKik/KCMuKik/LykgfHwgW10pLnNwbGljZSgxKTtcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2gsXG4gICAgaGFzaFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VBdXRoKGlucHV0ID0gXCJcIikge1xuICBjb25zdCBbdXNlcm5hbWUsIHBhc3N3b3JkXSA9IGlucHV0LnNwbGl0KFwiOlwiKTtcbiAgcmV0dXJuIHtcbiAgICB1c2VybmFtZTogZGVjb2RlKHVzZXJuYW1lKSxcbiAgICBwYXNzd29yZDogZGVjb2RlKHBhc3N3b3JkKVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VIb3N0KGlucHV0ID0gXCJcIikge1xuICBjb25zdCBbaG9zdG5hbWUsIHBvcnRdID0gKGlucHV0Lm1hdGNoKC8oW14vOl0qKTo/KFxcZCspPy8pIHx8IFtdKS5zcGxpY2UoMSk7XG4gIHJldHVybiB7XG4gICAgaG9zdG5hbWU6IGRlY29kZShob3N0bmFtZSksXG4gICAgcG9ydFxuICB9O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UGFyc2VkVVJMKHBhcnNlZCkge1xuICBjb25zdCBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZSB8fCBcIlwiO1xuICBjb25zdCBzZWFyY2ggPSBwYXJzZWQuc2VhcmNoID8gKHBhcnNlZC5zZWFyY2guc3RhcnRzV2l0aChcIj9cIikgPyBcIlwiIDogXCI/XCIpICsgcGFyc2VkLnNlYXJjaCA6IFwiXCI7XG4gIGNvbnN0IGhhc2ggPSBwYXJzZWQuaGFzaCB8fCBcIlwiO1xuICBjb25zdCBhdXRoID0gcGFyc2VkLmF1dGggPyBwYXJzZWQuYXV0aCArIFwiQFwiIDogXCJcIjtcbiAgY29uc3QgaG9zdCA9IHBhcnNlZC5ob3N0IHx8IFwiXCI7XG4gIGNvbnN0IHByb3RvID0gcGFyc2VkLnByb3RvY29sIHx8IHBhcnNlZFtwcm90b2NvbFJlbGF0aXZlXSA/IChwYXJzZWQucHJvdG9jb2wgfHwgXCJcIikgKyBcIi8vXCIgOiBcIlwiO1xuICByZXR1cm4gcHJvdG8gKyBhdXRoICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn1cbmNvbnN0IEZJTEVOQU1FX1NUUklDVF9SRUdFWCA9IC9cXC8oW14vXStcXC5bXi9dKykkLztcbmNvbnN0IEZJTEVOQU1FX1JFR0VYID0gL1xcLyhbXi9dKykkLztcbmZ1bmN0aW9uIHBhcnNlRmlsZW5hbWUoaW5wdXQgPSBcIlwiLCB7IHN0cmljdCB9KSB7XG4gIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHBhcnNlVVJMKGlucHV0KTtcbiAgY29uc3QgbWF0Y2hlcyA9IHN0cmljdCA/IHBhdGhuYW1lLm1hdGNoKEZJTEVOQU1FX1NUUklDVF9SRUdFWCkgOiBwYXRobmFtZS5tYXRjaChGSUxFTkFNRV9SRUdFWCk7XG4gIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IHZvaWQgMDtcbn1cblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgJFVSTCB7XG4gIGNvbnN0cnVjdG9yKGlucHV0ID0gXCJcIikge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwcm90b2NvbFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaG9zdFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXV0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGF0aG5hbWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInF1ZXJ5XCIsIHt9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFzaFwiKTtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgVVJMIGlucHV0IHNob3VsZCBiZSBzdHJpbmcgcmVjZWl2ZWQgJHt0eXBlb2YgaW5wdXR9ICgke2lucHV0fSlgXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVVSTChpbnB1dCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGRlY29kZShwYXJzZWQucHJvdG9jb2wpO1xuICAgIHRoaXMuaG9zdCA9IGRlY29kZShwYXJzZWQuaG9zdCk7XG4gICAgdGhpcy5hdXRoID0gZGVjb2RlKHBhcnNlZC5hdXRoKTtcbiAgICB0aGlzLnBhdGhuYW1lID0gZGVjb2RlUGF0aChwYXJzZWQucGF0aG5hbWUpO1xuICAgIHRoaXMucXVlcnkgPSBwYXJzZVF1ZXJ5KHBhcnNlZC5zZWFyY2gpO1xuICAgIHRoaXMuaGFzaCA9IGRlY29kZShwYXJzZWQuaGFzaCk7XG4gIH1cbiAgZ2V0IGhvc3RuYW1lKCkge1xuICAgIHJldHVybiBwYXJzZUhvc3QodGhpcy5ob3N0KS5ob3N0bmFtZTtcbiAgfVxuICBnZXQgcG9ydCgpIHtcbiAgICByZXR1cm4gcGFyc2VIb3N0KHRoaXMuaG9zdCkucG9ydCB8fCBcIlwiO1xuICB9XG4gIGdldCB1c2VybmFtZSgpIHtcbiAgICByZXR1cm4gcGFyc2VBdXRoKHRoaXMuYXV0aCkudXNlcm5hbWU7XG4gIH1cbiAgZ2V0IHBhc3N3b3JkKCkge1xuICAgIHJldHVybiBwYXJzZUF1dGgodGhpcy5hdXRoKS5wYXNzd29yZCB8fCBcIlwiO1xuICB9XG4gIGdldCBoYXNQcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5sZW5ndGg7XG4gIH1cbiAgZ2V0IGlzQWJzb2x1dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzUHJvdG9jb2wgfHwgdGhpcy5wYXRobmFtZVswXSA9PT0gXCIvXCI7XG4gIH1cbiAgZ2V0IHNlYXJjaCgpIHtcbiAgICBjb25zdCBxID0gc3RyaW5naWZ5UXVlcnkodGhpcy5xdWVyeSk7XG4gICAgcmV0dXJuIHEubGVuZ3RoID4gMCA/IFwiP1wiICsgcSA6IFwiXCI7XG4gIH1cbiAgZ2V0IHNlYXJjaFBhcmFtcygpIHtcbiAgICBjb25zdCBwID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLnF1ZXJ5KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucXVlcnlbbmFtZV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgcC5hcHBlbmQobmFtZSwgdik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAuYXBwZW5kKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgZ2V0IG9yaWdpbigpIHtcbiAgICByZXR1cm4gKHRoaXMucHJvdG9jb2wgPyB0aGlzLnByb3RvY29sICsgXCIvL1wiIDogXCJcIikgKyBlbmNvZGVIb3N0KHRoaXMuaG9zdCk7XG4gIH1cbiAgZ2V0IGZ1bGxwYXRoKCkge1xuICAgIHJldHVybiBlbmNvZGVQYXRoKHRoaXMucGF0aG5hbWUpICsgdGhpcy5zZWFyY2ggKyBlbmNvZGVIYXNoKHRoaXMuaGFzaCk7XG4gIH1cbiAgZ2V0IGVuY29kZWRBdXRoKCkge1xuICAgIGlmICghdGhpcy5hdXRoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3QgeyB1c2VybmFtZSwgcGFzc3dvcmQgfSA9IHBhcnNlQXV0aCh0aGlzLmF1dGgpO1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodXNlcm5hbWUpICsgKHBhc3N3b3JkID8gXCI6XCIgKyBlbmNvZGVVUklDb21wb25lbnQocGFzc3dvcmQpIDogXCJcIik7XG4gIH1cbiAgZ2V0IGhyZWYoKSB7XG4gICAgY29uc3QgYXV0aCA9IHRoaXMuZW5jb2RlZEF1dGg7XG4gICAgY29uc3Qgb3JpZ2luV2l0aEF1dGggPSAodGhpcy5wcm90b2NvbCA/IHRoaXMucHJvdG9jb2wgKyBcIi8vXCIgOiBcIlwiKSArIChhdXRoID8gYXV0aCArIFwiQFwiIDogXCJcIikgKyBlbmNvZGVIb3N0KHRoaXMuaG9zdCk7XG4gICAgcmV0dXJuIHRoaXMuaGFzUHJvdG9jb2wgJiYgdGhpcy5pc0Fic29sdXRlID8gb3JpZ2luV2l0aEF1dGggKyB0aGlzLmZ1bGxwYXRoIDogdGhpcy5mdWxscGF0aDtcbiAgfVxuICBhcHBlbmQodXJsKSB7XG4gICAgaWYgKHVybC5oYXNQcm90b2NvbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGVuZCBhIFVSTCB3aXRoIHByb3RvY29sXCIpO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHRoaXMucXVlcnksIHVybC5xdWVyeSk7XG4gICAgaWYgKHVybC5wYXRobmFtZSkge1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHdpdGhUcmFpbGluZ1NsYXNoKHRoaXMucGF0aG5hbWUpICsgd2l0aG91dExlYWRpbmdTbGFzaCh1cmwucGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAodXJsLmhhc2gpIHtcbiAgICAgIHRoaXMuaGFzaCA9IHVybC5oYXNoO1xuICAgIH1cbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuaHJlZjtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ocmVmO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVVUkwoaW5wdXQpIHtcbiAgcmV0dXJuIG5ldyAkVVJMKGlucHV0KTtcbn1cblxuZXhwb3J0IHsgJFVSTCwgY2xlYW5Eb3VibGVTbGFzaGVzLCBjcmVhdGVVUkwsIGRlY29kZSwgZGVjb2RlUGF0aCwgZGVjb2RlUXVlcnlLZXksIGRlY29kZVF1ZXJ5VmFsdWUsIGVuY29kZSwgZW5jb2RlSGFzaCwgZW5jb2RlSG9zdCwgZW5jb2RlUGFyYW0sIGVuY29kZVBhdGgsIGVuY29kZVF1ZXJ5SXRlbSwgZW5jb2RlUXVlcnlLZXksIGVuY29kZVF1ZXJ5VmFsdWUsIGdldFF1ZXJ5LCBoYXNMZWFkaW5nU2xhc2gsIGhhc1Byb3RvY29sLCBoYXNUcmFpbGluZ1NsYXNoLCBpc0VtcHR5VVJMLCBpc0VxdWFsLCBpc05vbkVtcHR5VVJMLCBpc1JlbGF0aXZlLCBpc1NhbWVQYXRoLCBpc1NjcmlwdFByb3RvY29sLCBqb2luUmVsYXRpdmVVUkwsIGpvaW5VUkwsIG5vcm1hbGl6ZVVSTCwgcGFyc2VBdXRoLCBwYXJzZUZpbGVuYW1lLCBwYXJzZUhvc3QsIHBhcnNlUGF0aCwgcGFyc2VRdWVyeSwgcGFyc2VVUkwsIHJlc29sdmVVUkwsIHN0cmluZ2lmeVBhcnNlZFVSTCwgc3RyaW5naWZ5UXVlcnksIHdpdGhCYXNlLCB3aXRoRnJhZ21lbnQsIHdpdGhIdHRwLCB3aXRoSHR0cHMsIHdpdGhMZWFkaW5nU2xhc2gsIHdpdGhQcm90b2NvbCwgd2l0aFF1ZXJ5LCB3aXRoVHJhaWxpbmdTbGFzaCwgd2l0aG91dEJhc2UsIHdpdGhvdXRGcmFnbWVudCwgd2l0aG91dEhvc3QsIHdpdGhvdXRMZWFkaW5nU2xhc2gsIHdpdGhvdXRQcm90b2NvbCwgd2l0aG91dFRyYWlsaW5nU2xhc2ggfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ufo/dist/index.mjs\n");

/***/ })

};
;